
## Audience
The course is designed primarily for bootcamp graduates preparing for technical interviews, as well as busy professionals with limited time to study. Participants will have varying levels of prior experience, but most will have completed a web development or software engineering program. This first offering will be free for those actively seeking employment.
Many learners have been job searching for an extended period, so the course must be **accessible, motivating, and confidence-building**. It should leave students with a sense of progress and renewed momentum. As adult learners, participants will benefit most when the material clearly communicates _why it matters_ — tying concepts to real-world relevance and interview success.
## Goal of the course
This course introduces learners to the core data structures, algorithms, and performance concepts most commonly tested in junior-level technical interviews. It also equips students with practical strategies and ample hands-on practice to approach live coding challenges with confidence.
## Learning Objectives
The course is structured around the first three levels of Bloom’s Taxonomy—**Remember**, **Understand**, and **Apply**—with learning objectives organized according to these progressive skill development categories.

| Category                      | Learning Objective Name                                                                                                                                                                | Bloom Level          |
| ----------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------- |
| Data Structure Arrays         | Implement code to iterate over the elements of a Array to perform an operation on each element                                                                                         | Apply                |
|                               | Implement code to add an object to an Array                                                                                                                                            | Apply                |
|                               | Implement code to remove an object from an Array                                                                                                                                       | Apply                |
|                               | Implement code to update values stored in a two-dimensional array and know its                                                                                                         | Apply                |
|                               | Implement code to find the neighbors of a cell in a two-dimensional array                                                                                                              | Remember, Understand |
|                               | Explain why inserting or removing a value by index in an Array runs in linear O(n) time                                                                                                | Remember, Understand |
|                               | Explain BigO runtime of popular array methods .push .pop .shift .unshift .map .filter                                                                                                  | Remember, Understand |
| Data Structure<br>Linked List | Implement code to iterate over the elements of a Linked List to perform an operation on each element                                                                                   | Apply                |
|                               | Build a Linked List without using built-in libraries                                                                                                                                   | Apply                |
|                               | Implement code to add an object to a Linked List                                                                                                                                       | Apply                |
|                               | Implement code to remove an object from a Linked List                                                                                                                                  | Apply                |
|                               | Explain why accessing a value by index from an Linked List runs is linear O(n) time                                                                                                    | Remember, Understand |
|                               | Explain why inserting or removing a value by index in an Linked List runs in linear O(n) time                                                                                          | Remember, Understand |
|                               | **Differentiate** between singly, doubly, and circular linked lists.                                                                                                                   | Remember, Understand |
|                               | **Describe** the advantages and disadvantages of arrays and linked lists in terms of memory layout, resizing, and access time.                                                         | Remember, Understand |
| Data Structure Map            | Implement code to add a key-value pair to a Map                                                                                                                                        | Apply                |
|                               | Build a Map without using built-in libraries                                                                                                                                           | Apply                |
|                               | Implement code to retrieve a value by key from a Map and know it's runtime.                                                                                                            | Apply                |
|                               | Implement code to remove a key-value pair from a Map and know its runtime                                                                                                              | Apply                |
|                               | Explain why accessing a value by key in a Map typically runs in constant O(1) time                                                                                                     | Remember, Understand |
|                               | Explain BigO runtime of popular Map methods .get .set .has .delete .size .keys .values()                                                                                               | Remember, Understand |
| Data Structure Set            | Implement code to add a value to a Set  and know it's runtime.                                                                                                                         | Apply                |
|                               | Build a Set without using built-in libraries                                                                                                                                           | Apply                |
|                               | Implement code to check if a value exists in a Set  and know it's runtime.                                                                                                             | Apply                |
|                               | Implement code to remove a value from a Set and know it's runtime.                                                                                                                     | Apply                |
|                               | Explain why Set operations (add, delete, has) typically run in constant O(1) time                                                                                                      | Remember, Understand |
|                               | Describe how Sets prevent duplicate values and when that is beneficial                                                                                                                 | Understand           |
|                               | Compare the behavior of Sets to Maps when storing unique values                                                                                                                        | Understand           |
| Data Structure Stack          | Implement code to push a value onto a Stack  and know it's runtime.                                                                                                                    | Apply                |
|                               | Build a LIFO Stack without using built-in libraries                                                                                                                                    | Apply                |
|                               | Implement code to pop a value from a Stack  and know it's runtime.                                                                                                                     | Apply                |
|                               | Implement code to peek at the top value in a Stack and know it's runtime.                                                                                                              | Apply                |
|                               | Explain why Stack operations run in constant O(1) time                                                                                                                                 | Remember, Understand |
|                               | Identify real-world or interview problems where Stack is the ideal data structure                                                                                                      | Remember, Understand |
|                               | Compare Stack behavior to Queue behavior and describe differences in use cases                                                                                                         | Remember, Understand |
| Data Structure Queue          | Implement code to enqueue a value in a Queue and know it's runtime.                                                                                                                    | Apply                |
|                               | Build a FIFO Queue without using built-in libraries                                                                                                                                    | Apply                |
|                               | Implement code to dequeue a value from a Queue and know it's runtime.                                                                                                                  | Apply                |
|                               | Implement code to peek at the front value in a Queue and know it's runtime.                                                                                                            | Apply                |
|                               | Explain why Queue operations (enqueue/dequeue) typically run in constant O(1) time(Linked List) or O(n) (Array)                                                                        | Remember, Understand |
|                               | Compare performance trade-offs between array-based and linked-list-based Queue implementations                                                                                         | Remember, Understand |
| Sort                          | Use a pre-existing sort implementation to sort a collection of objects according to their natural ordering vs custom order and understand why the sort algoritms runtime is O(n log n) | Apply                |
|                               | Know that different sorting algorithm exist know about the most common ones and their runtimes (bubble, merge select sort)                                                             | Remember             |
| BigO                          | Define and Describe Big O Notation                                                                                                                                                     | Remember, Understand |
|                               | Know the difference between Time and Space complexity                                                                                                                                  | Remember, Understand |
|                               | Know what constants are and why we can drop them from Big O notation.                                                                                                                  | Remember, Understand |
|                               | Students will be able to **analyze simple code snippets** and determine their **time and space complexity** using Big O.                                                               | Apply                |
|                               | Students will be able to **order common complexities** from best to worst O(1) < O(log n) < O(n) < O(n log n) < O(n²)                                                                  | Remember, Understand |
|                               |                                                                                                                                                                                        |                      |
|                               | Students will be able to **choose or write more efficient code** based on Big O trade-offs.                                                                                            | Apply                |
|                               | Students will be able to **explain the time complexity** of common operations (insert, lookup, delete) on Arrays, Lists Maps, Stacks, Queues and Sets.                                 | Apply                |
| Algorithms Two Pointer        | Students will be able to **explain what the two pointer technique is** and **identify when it's appropriate** to use it.                                                               | Remember, Understand |
|                               | Solve a problem using a two pointers technique                                                                                                                                         | Apply                |
|                               | Students will be able to evaluate and compare the efficiency of a two pointer solution against a naive nested loop version.                                                            | Apply                |
| Algorithms <br>Sliding Window | Students will be able to explain what the sliding window technique is and identify when it's appropriate to use it.                                                                    | Remember, Understand |
|                               | Solve a problem using a sliding window technique                                                                                                                                       | Apply                |
|                               | Students will be able to evaluate and compare the efficiency of a sliding window solution against a naive nested loop version.                                                         | Apply                |
| Algorithms<br>Binary Search   | Students will be able to explain what Binary Search technique is and identify when it's appropriate to use it (sorted collection).                                                     | Remember, Understand |
|                               | Solve a problem using a Binary Search technique                                                                                                                                        | Apply                |
|                               | Students will be able to **evaluate and compare** the efficiency of a Binary Search solution against a naive nested loop version.                                                      | Apply                |
| Problem Solving<br>           | Student will be able to recall the 5 steps of the Algorithm solving guide <br>Clarify > Plan > Implement > Test > Optimize                                                             | Remember, Understand |
|                               | Student can solve a problem using the 5 steps of the Algorithm solving guide <br>Clarify > Plan > Implement > Test > Optimize                                                          | Apply                |
## Course Outline 

### **Module 1: Algorithmic Thinking & Big-O**

**Concepts:**
- What is an algorithm? 
- What is a Data Structure?
- The 5-step problem-solving process (Clarify → Plan → Implement → Test → Optimize)
- Big-O notation: time vs space complexity
- Comparing common complexities: O(1), O(n), O(log n), O(n²)

**Hands-On Problems:**
- Compare performance of naive vs optimized functions
- Analyze time complexity of provided snippets
- Build a Big-O reference table
### **Module 2: Arrays & Two Pointers**

**Data Structure:** Arrays  
**Technique:** Two Pointers  
**Concepts:**
- Core operations: add, remove, update, access by index
- Tradeoffs in insert/delete by index (O(n) cost)
- Methods: `.push`, `.pop`, `.shift`, `.unshift`, `.map`, `.filter`
- Two-pointer logic for pairwise traversal

**Hands-On Problems:**
- Reverse an array in-place
- Remove duplicates from sorted array
- Move zeroes to the end
- Merge two sorted arrays using two pointers
### **Module 3: 2D Arrays & Grid Navigation**

**Data Structure:** 2D Arrays  
**Technique:** Grid traversal (directional patterns)  
**Concepts:**
- Indexing and bounds checking in grids
- Finding neighbors (up/down/left/right)

**Hands-On Problems:**
- Count live neighbors
- Find number of islands (connected regions)
- Flip surrounded regions
- Identify the edge of a shape in a grid
### **Module 4: Linked Lists & Pointer Manipulation**

**Data Structure:** Linked List  
**Technique:** Pointer iteration & modification  
**Concepts:**
- Singly vs doubly vs circular linked lists
- Tradeoffs: access time vs insertion/removal
- Node-based traversal and manual linking

**Build from Scratch:**
- Implement a singly linked list class with `add`, `remove`, `insertAt`, `get`

**Hands-On Problems:**
- Reverse a linked list
- Find middle of a linked list
- Detect a cycle
- Merge two sorted lists
### **Module 5: Stacks, Queues**

**Data Structures:** Stack & Queue  
**Technique:** Simulation & sequence management  
**Concepts:**
- Stack (LIFO): call stack, backtracking
- Queue (FIFO): scheduling, buffering
- Tradeoffs of array vs linked list implementations

**Build from Scratch:**
- Implement a stack class (push, pop, peek)
- Implement a queue class (enqueue, dequeue, peek)

**Hands-On Problems:**
- Balanced parentheses
- Undo/redo simulation
- Implement a browser back/forward history
- Simulate task queue

### **Module 6: Maps & Sets**

**Data Structures:** Map & Set  
**Technique:** Lookup optimization  
**Concepts:**
- Use cases for key-value and uniqueness structures
- Frequency counting, fast lookup, deduplication
- Constant-time operations with hashing

**Build from Scratch:**
- Implement a basic Map using a hash table
- Implement a Set structure with add, delete, has

**Hands-On Problems:**
- First unique character
- Group anagrams
- Detect duplicates in a list
- Word pattern matcher
    
### **Module 7: Sliding Window Technique**

**Data Structure:** Arrays / Strings  
**Technique:** Sliding Window (fixed and dynamic)  
**Concepts:**
- Optimizing nested loops
- Maintaining window state
- Subarrays and substrings

**Hands-On Problems:**
- Max sum subarray of size k
- Longest substring without repeating characters
- Minimum window substring
- Longest subarray with sum ≤ k

### **Module 8: Sorting & Binary Search**

**Data Structure:** Sorted Arrays  
**Technique:** Divide and Conquer (Binary Search)  
**Concepts:**
- Common sorting approaches: bubble, selection, merge (overview)
- Using `.sort()` with comparators
- Binary search fundamentals and variants

**Hands-On Problems:**
- Implement binary search
- Find first/last index in sorted array
- Search in rotated array
- Sort by frequency or priority
### **Module 9: Combining Patterns & Tradeoff Analysis**

**Data Structures:** Arrays, Sets, Maps, Lists  
**Techniques:** Two Pointers, Sliding Window  
**Concepts:**
- Recognizing patterns in problem statements
- Choosing the right structure for the job
- Analyzing tradeoffs of space vs speed

**Hands-On Problems:**
- Longest consecutive sequence
- Merge intervals
- Top K frequent elements
- Detect and remove loops in linked lists

### **Module 10: Interview Readiness a Recap**

**Concepts:**
- Solving problems end-to-end under constraints
- Explaining code and tradeoffs
- Thinking aloud and clarifying requirements
- Clean, testable, efficient solutions

**Activities:**
- Mock interviews
- Final problem set
- Reflect on strategy and approach
- Receive and give peer feedback



