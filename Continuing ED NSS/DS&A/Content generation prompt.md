
Need 6 hours of individual anyncronous activity including readings , exercises and

videos to cover Concepts and Hands-On Problems below and

completing it should meet the leaning objectives in Problem Solving and Big O listed.

The content should follow these principles:

USe the javascript programming language

Small chunks to support micro lessons

incorporate recall practice

  
  

# Concepts:

- What is an algorithm?

- What is a Data Structure?

- The 5-step problem-solving process (Clarify → Plan → Implement → Test → Optimize)

- Big-O notation: time vs space complexity

- Comparing common complexities: O(1), O(n), O(log n), O(n²)

  

# Hands-On Problems:

- Compare performance of naive vs optimized functions

- Analyze time complexity of provided snippets

- Build a Big-O reference table

  

# Learning Objectives:

  

### Problem Solving

- Students will be able to **recall** the five steps of the algorithm-solving guide: **Clarify, Plan, Implement, Test, and Optimize**. (Remember, Understand)

- Students will be able to **solve problems** by applying the five steps of the algorithm-solving guide: **Clarify, Plan, Implement, Test, and Optimize**. (Apply)

  

### Big O

- Students will be able to **define and describe** Big O notation. (Remember, Understand)

- Students will be able to **distinguish** between time complexity and space complexity. (Remember, Understand)

- Students will be able to **explain what constants are** and why they can be dropped from Big O notation. (Remember, Understand)

- Students will be able to **analyze simple code snippets** and **determine their time and space complexity** using Big O. (Apply)

- Students will be able to **order common complexities** from best to worst: **O(1) < O(log n) < O(n) < O(n log n) < O(n²)**. (Remember, Understand)

- Students will be able to **choose or write more efficient code** based on Big O trade-offs. (Apply)

- Students will be able to **explain the time complexity** of common operations such as insert, lookup, and delete on **arrays, lists, maps, stacks, queues, and sets**. (Apply)